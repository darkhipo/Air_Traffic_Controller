package FlightCoordination;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Semaphore;

import au.com.bytecode.opencsv.CSV;
import au.com.bytecode.opencsv.CSVReadProc;
import au.com.bytecode.opencsv.CSVWriteProc;
import au.com.bytecode.opencsv.CSVWriter;

public class Utils {
	/*Fill-in values for missing data. Generated by reading in the CSV.*/
	public static Double rewardMedian   ;
	public static Double fillMedian     ;
	public static Double timeMaxMedian  ;
	public static Double timeAverageFailMedian ;
	public static Double timeAverageSuccMedian ;
	public static Double timeStdDevFailMedian ;
	public static Double timeStdDevSuccMedian ;

	public static Random rand = new Random()  ;
	
	public static void preProcessFlights (List <Flight> fl){
		List <Flight> toRemove = new ArrayList <Flight> ();
		for (Flight f : fl){
	        if (f.getReward() <= ParameterCore.CLOSE_TO_ZERO) {
	            f.setReward( rewardMedian * ParameterCore.NO_REWARD_DEMERIT_COEFF );
	            f.setNoDat(true);
	        }
            if (f.getProbability() <= ParameterCore.CLOSE_TO_ZERO) {
                f.setProbability(fillMedian);
                f.setNoDat(true);
            }
            if (f.getTimeMax() <= ParameterCore.CLOSE_TO_ZERO) {
                f.setTimeMax(timeMaxMedian);
                f.setNoDat(true);
            }
            if (f.getTimeAverageFailure() <= ParameterCore.CLOSE_TO_ZERO) {
            	if(f.getTimeAverageSuccess() > ParameterCore.CLOSE_TO_ZERO){
            		f.setTimeAverageFailure(f.getTimeAverageSuccess());
            	}
            	else{
            		f.setTimeAverageFailure(timeAverageFailMedian);
            	}
            }
            if (f.getTimeAverageSuccess() <= ParameterCore.CLOSE_TO_ZERO) {
            	if(f.getTimeAverageFailure() > ParameterCore.CLOSE_TO_ZERO){
            		f.setTimeAverageSuccess(f.getTimeAverageFailure());
            	}
            	else{
            		f.setTimeAverageSuccess(timeAverageSuccMedian);
            	}
            }
            if (f.getTimeStdDevFailure() <= ParameterCore.CLOSE_TO_ZERO) {
            	if(f.getTimeStdDevSuccess() > ParameterCore.CLOSE_TO_ZERO){
            		f.setTimeStdDevFailure(f.getTimeStdDevSuccess());
            	}
            	else{
                    f.setTimeStdDevFailure(timeStdDevFailMedian);
            	}
            }
            if (f.getTimeStdDevSuccess() <= ParameterCore.CLOSE_TO_ZERO) {
            	if(f.getTimeStdDevFailure() > ParameterCore.CLOSE_TO_ZERO){
            		f.setTimeStdDevSuccess(f.getTimeStdDevFailure());
            	}
            	else{
            		f.setTimeStdDevSuccess(timeStdDevSuccMedian);
            	}
            }
            if ( f.getNoDat() && ParameterCore.SKIP_NODAT ){
            	toRemove.add(f);
            }
	    }
	    if (ParameterCore.SKIP_NODAT){
	    	fl.removeAll(toRemove);
	    }
	}
	public static List<Placement> partitionToPlacements( List<Flight> allFlights ){
		HashMap<String, Placement> pHash = new HashMap<String, Placement> ();
		for(Flight f : allFlights){
			if( pHash.containsKey(f.getPlacementToken()) ){
				Placement p = pHash.get(f.getPlacementToken());
				p.addFlight(f);
			}
			else{
				FlightPlan nfp = new FlightPlan(Collections.synchronizedList(new ArrayList<Flight>()));
				pHash.put(f.getPlacementToken(), new Placement(f.getPlacementToken(), nfp));
				nfp.addFlight(f);
			}
		}
		return Collections.synchronizedList(new ArrayList<Placement>(pHash.values()));
	}
	public static void optimizePlacements(Integer waterfallSizeLimit, String control, List<Placement> allPlacements) throws InterruptedException, IOException {
		clearFile(ParameterCore.LOG_LOC);
		PrintWriter logger  = new PrintWriter( new FileWriter( ParameterCore.LOG_LOC) );
		Semaphore semaphore = new Semaphore(ParameterCore.CORES);
		ArrayList<OptimizingThread> alot = new ArrayList<OptimizingThread> (); 
		int done = 1;
		if (ParameterCore.RUN_PARALLEL){
			for (Placement p : allPlacements){
				alot.add(new OptimizingThread(waterfallSizeLimit, control, semaphore, p));
				alot[(len(alot) - 1)].start();
			}
			for (OptimizingThread t : alot){
				t.join();
				String s = String.format("%-16d : %-16d : %-16d : %-16s : %-16d : %-16f\n",System.currentTimeMillis(),done,allPlacements.size(),t.getPid(),t.getP().getFp().size(),t.getExp());  
				logger.write(s);
				logger.flush();
				done++;
			}
		}
		else{
			for (Placement p : allPlacements){
				optimizePlacement(waterfallSizeLimit, control, p);
				String s = String.format("%-16d : %-16d : %-16d : %-16s : %-16d : %-16f\n",System.currentTimeMillis(),done,allPlacements.size(),p.getPid(),p.getFp().size(),p.getFp().getExpectedValue());  
				logger.write(s);
				logger.flush();
				done++;
			}
		}
		logger.close();
	}
	static void optimizePlacement(Integer waterfallSizeLimit, String control, Placement p) throws InterruptedException, AssertionError {
		Integer fallSize = Math.min( waterfallSizeLimit, p.size() );
		List<Flight> candidates = p.getFp().getAsList();
		FlightPlan fp = null;
		//Initial flight plan, on which to run optimization. (Order by decreasing reward).
		//Split off the N highest reward flights. 
		//Note: candidates IS modified after the operation.
		if (ParameterCore.BOOTSTRAP_METHOD == FlightPlanBootstrapSplitEnum.ORDERED_SPLIT){
			fp = FlightPlanCoordinator.ordSplit(fallSize, candidates);
			fp.makeAdmissible();
		}
		else if (ParameterCore.BOOTSTRAP_METHOD == FlightPlanBootstrapSplitEnum.RANDOM_SPLIT) {
			fp = FlightPlanCoordinator.randSplit(fallSize, candidates);
		}
		else{
			throw new AssertionError();
		}
		//Optimize START.
		FlightPlanCoordinator fpc = new FlightPlanCoordinator(fp, candidates);
		if (control.equals(ParameterCore.DO_BFS)){
		    fp = fpc.runBruteForce();
		}
		else{
		    fp = fpc.runSLS();
		}
		p.setFp(fp);
		//Optimize END.
	}
	//Process all rows of input data that return true.
	public static Boolean doProcessRow(int rowIndex){
		if(ParameterCore.SKIP_FIRST_ROW && (rowIndex == 0) ){
			return false;
		}
		return true;
	}
	//placementToken, flight_id, cpm, fillRateProbability, latency for failure in seconds, latency of success in seconds.
	public static List<Flight> readFlightsCSV (CSV csv, String inFiNa){
		final List<Flight> flights = Collections.synchronizedList(new ArrayList<Flight>());
		rewardMedian      		 = null;
		fillMedian        		 = null;
		timeAverageFailMedian    = null;
		timeAverageSuccMedian    = null;
		timeMaxMedian     		 = null;
		final ArrayList<Double> rewList      = new ArrayList<Double>();
		final ArrayList<Double> fillList     = new ArrayList<Double>();
		final ArrayList<Double> tMaxList     = new ArrayList<Double>();
		final ArrayList<Double> atFailList   = new ArrayList<Double>();
		final ArrayList<Double> atSuccList   = new ArrayList<Double>();
		final ArrayList<Double> stdtFailList = new ArrayList<Double>();
		final ArrayList<Double> stdtSuccList = new ArrayList<Double>();

        rewList.add(0.0);
        fillList.add(0.0);
        tMaxList.add(0.0);
        atFailList.add(0.0);
        atSuccList.add(0.0);
        stdtFailList.add(0.0);
        stdtSuccList.add(0.0);
        
    	csv.read(inFiNa, new CSVReadProc() {
    	    public void procRow(int rowIndex, String... values) {
    	        if (Utils.doProcessRow(rowIndex)){
	                List<String> row 	 = Arrays.asList(values);
	                String pTok      	 = row.get(0);
	                String fId       	 = row.get(1);
	                Double reward    	 = isDouble(row.get(2)) ? Double.valueOf(row.get(2)) : 0.0;
	                Double fillRate  	 = isDouble(row.get(3)) ? Double.valueOf(row.get(3)) : 0.0;
	                Double t_maxx    	 = isDouble(row.get(4)) ? Double.valueOf(row.get(4)) : 0.0;
	                Double t_fail    	 = isDouble(row.get(5)) ? Double.valueOf(row.get(5)) : 0.0;
	                Double t_succ     	 = isDouble(row.get(6)) ? Double.valueOf(row.get(6)) : 0.0;
	                Double t_fail_std    = isDouble(row.get(7)) ? Double.valueOf(row.get(7)) : 0.0;
	                Double t_succ_std    = isDouble(row.get(8)) ? Double.valueOf(row.get(8)) : 0.0;

	                if (reward > 0.0){
	                	rewList.add(new Double(reward));
	                }
	                if (fillRate > 0.0){
	                	fillList.add(new Double(fillRate));
	                }
	                if (t_maxx > 0.0){
	                	tMaxList.add(new Double(t_maxx));
	                }
	                if (t_fail > 0.0){
	                	atFailList.add(new Double(t_fail));
	                }
	                if (t_succ > 0.0){
	                	atSuccList.add(new Double(t_succ));
	                }
	                if (t_fail_std > 0.0){
	                	stdtFailList.add(new Double(t_fail_std));
	                }
	                if (t_succ_std > 0.0){
	                	stdtSuccList.add(new Double(t_succ_std));
	                }

	                flights.add(new Flight(pTok, fId, reward, fillRate, t_maxx, 
	                		        t_fail, t_succ, t_fail_std, t_succ_std));
    	        }
    	    }
    	});	
    	
    	rewardMedian     		= Median(rewList);
        fillMedian      		= Median(fillList);
        timeMaxMedian    		= Median(tMaxList);
        timeAverageFailMedian   = Median(atFailList);
        timeAverageSuccMedian   = Median(atSuccList);
        timeStdDevFailMedian	= Median(stdtFailList);
        timeStdDevSuccMedian    = Median(stdtSuccList);

    	return flights;
	}
	public static void writeFlightPlanCSV (CSV csv, String outFiNa, final List<Flight> fp) {
		csv.write(outFiNa, new CSVWriteProc() {
    	    public void process(CSVWriter out) {
    	    	if (ParameterCore.SKIP_FIRST_ROW){
    	    	    FlightPlan X = new FlightPlan(fp);
    	    	    X.getExpectedValue();
    	    		out.writeNext("placement_token","flight_id","CPM","fill_rate","maxTime",
    	    				"averageRespFailTime","averageRespSuccTime",
    	    				"stdDevFailTime","stdDevSuccTime", X.probs);
    	    	}
    	    	for (Flight f : fp){
	    	        String pTok      = f.getPlacementToken();
	    	        String fId       = f.getFid();
	    	        String cpm       = Double.toString(roundDouble(f.getReward(),ParameterCore.SIG_FIGS));
	        		String fill      = Double.toString(roundDouble(f.getProbability(),ParameterCore.SIG_FIGS));
	        		String timeM     = Double.toString(roundDouble(f.getTimeMax(),ParameterCore.SIG_FIGS));
	        		String timeF     = Double.toString(roundDouble(f.getTimeAverageFailure(),ParameterCore.SIG_FIGS));
	        		String timeS     = Double.toString(roundDouble(f.getTimeAverageSuccess(),ParameterCore.SIG_FIGS));
	        		String timeF_std = Double.toString(roundDouble(f.getTimeStdDevFailure(),ParameterCore.SIG_FIGS));
	        		String timeS_std = Double.toString(roundDouble(f.getTimeStdDevSuccess(),ParameterCore.SIG_FIGS));
	        		
	        		if ( fId   == null || 
	        		     pTok  == null ||
	        			 cpm   == null || 
	        			 fill  == null ||
    					 timeM == null ||
	        			 timeF == null ||
	        			 timeS == null ||
	        			 timeF_std == null ||
	        			 timeS_std == null
	        			  )
	        		{
	        			throw new AssertionError();
	        		}
	        		out.writeNext(pTok,fId,cpm,fill,timeM,timeF,timeS,timeF_std,timeS_std);
    	    	}
    	   }
    	});
	}
	public static void writeFlightPlanCSV (CSV csv, String outFiNa, final FlightPlan fp) {
		writeFlightPlanCSV (csv, outFiNa, fp.getAsList());
	}
	public static <T> List<T> mergeLists( List<T> l1, List<T> l2 ){
		List<T> l3 = Collections.synchronizedList(new ArrayList<T>());
		l3.addAll(l1);
		l3.addAll(l2);
		return l3;
	}
	public static double Median(List<Double> values)
	{
	    Collections.sort(values);
	    if (values.size() % 2 == 1){
	    	return values.get((values.size()+1)/2-1);
	    }
	    else
	    {
	    	double lower = values.get(values.size()/2-1);
	    	double upper = values.get(values.size()/2);
	    	return (lower + upper) / 2.0;
	    }	
	}
	public static boolean isDouble( String str ){
	    try{
	      Double.parseDouble( str );
	      return true;
	    }
	    catch( Exception e ){
	      return false;
	    }
	}
	public static BigDecimal productHighPrecision(double ... dbls){
		BigDecimal base = new BigDecimal(1.0);
		for (double d : dbls){
			base = base.multiply(new BigDecimal(d));
		}
		return base;
	}
	public static BigDecimal sumHighPrecision(double ... dbls){
		BigDecimal base = new BigDecimal(1.0);
		for (double d : dbls){
			base = base.add(new BigDecimal(d));
		}
		return base;
	}
	public static double nextGaussian(double mean, double std_dev){
		//variance = std_dev^2
		return rand.nextGaussian()*Math.pow(std_dev, 2) + mean;
	}
	public static void clearFile(String fName){
		File fileTemp = new File(fName);
		if (fileTemp.exists()){
		    fileTemp.delete();
		}
	}
	public static double roundDouble(double value, int sigFigs){
		return (double)Math.round(value * Math.pow(10,sigFigs)) / Math.pow(10,sigFigs);
	}
}