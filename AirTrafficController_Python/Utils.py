import ParameterCore
import FlightPlanBootstrapSplitEnum
import FlightPlanCoordinator
from FlightPlan import FlightPlan
import Placement
import random
import decimal
import time
import numpy
import os
from pathlib import Path
import OptimizingThread
import threading


class Utils:                              # public class Utils {
    # Fill-in values for missing data. Generated by reading in the CSV.
    def __init__(self):
        self.rewardMedian = 0.0           # public static Double rewardMedian   ;
        self.fillMedian = 0.0             # public static Double fillMedian     ;
        self.timeMaxMedian = 0.0          # public static Double timeMaxMedian  ;
        self.timeAverageFailMedian = 0.0  # public static Double timeAverageFailMedian
        self.timeAverageSuccMedian = 0.0  # public static Double timeAverageSuccMedian
        self.timeStdDevFailMedian = 0.0   # public static Double timeStdDevFailMedian
        self.timeStdDevSuccMedian = 0.0   # public static Double timeStdDevSuccMedian
        self.rand = random.Random()       # public static Random rand = new Random()  ;


    def preProcessFlights(self, fl):
        toRemove = []
        for f in fl:
            if f.getReward() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                f.setReward(self.rewardMedian * ParameterCore.ParameterCore().NO_REWARD_DEMERIT_COEFF)
                f.setNoDat(True)
            if f.getProbability() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                f.setProbability(self.fillMedian)
                f.setNoDat(True)
            if f.getTimeMax() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                f.setTimeMax(self.timeMaxMedian)
                f.setNoDat(True)
            if f.getTimeAverageFailure() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeAverageSuccess() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeAverageFailure(f.getTimeAverageSuccess)
                else:
                    f.setTimeAverageFailure(self.timeAverageFailMedian)
            if f.getTimeAverageSuccess <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeAverageFailure() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeAverageSuccess(f.getTimeAverageFailure)
                else:
                    f.setTimeAverageSuccess(self.timeAverageSuccMedian)
            if f.getTimeStdDevFailure() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeStdDevSuccess() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeStdDevFailure(f.getTimeStdDevSuccess)
                else:
                    f.setTimeStdDevFailure(self.timeStdDevFailMedian)
            if f.getTimeStdDevSuccess() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeStdDevFailure() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeStdDevSuccess(f.getTimeStdDevFailure())
                else:
                    f.setTimeStdDevSuccess(self.timeStdDevSuccMedian)
            if f.getNoDat() and ParameterCore.ParameterCore().SKIP_NODAT:
                    toRemove.append(f)
        if ParameterCore.ParameterCore().SKIP_NODAT:
            fl = [x for x in fl if x not in toRemove]

    def partitionToPlacements(self, allFlights):
        pHash = dict()
        for f in allFlights:
            if f.getPlacementToken() in pHash.keys():
                p = pHash[f.getPlacementToken]
                p.addFlight(f)
            else:
                nfp = FlightPlan([])
                pHash.update({f.getPlacementToken: Placement.Placement(f.getPlacementToken(), nfp)})
                nfp.addFlight(f)
        return list()





    def optimizePlacements(self, waterfallSizeLimit, control, allPlacements):
        self.clearFile(ParameterCore.ParameterCore().LOG_LOC)
        ########## PrintWriter logger  = new PrintWriter( new FileWriter( ParameterCore.LOG_LOC) );
        semaphore = threading.Semaphore(ParameterCore.ParameterCore().CORES)
        with open(ParameterCore.ParameterCore().LOG_LOC, "w+") as logger:            # logger = PrintWriter(FileWriter(ParameterCore.ParameterCore().LOG_LOC))

            alot = []   # ArrayList<OptimizingThread> alot = new ArrayList<OptimizingThread> ();
            done = 1

            if ParameterCore.ParameterCore().RUN_PARALLEL:
                for p in allPlacements:
                    alot.append(OptimizingThread.OptimizingThread(waterfallSizeLimit, control, semaphore, p))
                    alot[(len(alot) - 1)].start()

                for t in alot:
                    t.join()
                    s = "{} : {} : {} : {} : {} : {}\n".format(int(round(time.time() * 1000)), done, allPlacements.size(), t.getPid(), t.getP().getFp().size(), t.getExp())
                    logger.write(s)
                    logger.flush()
                    done += 1

            else:
                for p in allPlacements:
                    self.optimizePlacement(waterfallSizeLimit, control, p)
                    s = "{} : {} : {} : {} : {} : {}\n".format(int(round(time.time() * 1000)), done, allPlacements.size(), p.getPid(), p.getFp().size(),p.getFp().getExpectedValue())
                    logger.write(s)
                    logger.flush()
                    done += 1
        logger.close()



    def optimizePlacement(self, waterfallSizeLimit, control, p):
        fallSize = min(waterfallSizeLimit, p.size())
        candidates = p.getFp().getAsList()
        fp = None
        # Initial flight plan, on which to run optimization. (Order by decreasing reward).
		# Split off the N highest reward flights.
		# Note: candidates IS modified after the operation.

        if ParameterCore.ParameterCore().BOOTSTRAP_METHOD == FlightPlanBootstrapSplitEnum.FlightPlanBootstrapSplitEnum().ORDERED_SPLIT:
            fp = FlightPlanCoordinator.ordSplit(fallSize, candidates)
            fp.makeAdmissible()
        elif ParameterCore.ParameterCore().BOOTSTRAP_METHOD == FlightPlanBootstrapSplitEnum.FlightPlanBootstrapSplitEnum().RANDOM_SPLIT:
            fp = FlightPlanCoordinator.FlightPlanCoordinator(fallSize, candidates).randSplit()
        else:
            raise AssertionError()

        # Optimize START.
        fpc = FlightPlanCoordinator.FlightPlanCoordinator(fp, candidates)
        if control.equals(ParameterCore.ParameterCore().DO_BFS):
            fp = fpc.runBruteForce()
        else:
            fp = fpc.runSLS()
        p.setFp(fp)
        # Optimize END.

        # Process all rows of input data that return true.
        def doProcessRow(self, rowIndex):
            if ParameterCore.ParameterCore().SKIP_FIRST_ROW and rowIndex == 0:
                return False
            return True



    # placementToken, flight_id, cpm, fillRateProbability, latency for failure in seconds, latency of success in seconds.
    def readFlightsCSV(self, csv, inFiNa):
        flights = []
        self.rewardMedian = None
        self.fillMedian = None
        self.timeAverageFailMedian = None
        self.timeAverageSuccMedian = None
        self.timeMaxMedian = None

        rewList = []
        fillList = []
        tMaxList = []
        atFailList = []
        atSuccList = []
        stdtFailList = []
        stdtSuccList = []

        rewList.append(0.0)
        fillList.append(0.0)
        tMaxList.append(0.0)
        atFailList.append(0.0)
        atSuccList.append(0.0)
        stdtFailList.append(0.0)
        stdtSuccList.append(0.0)

        # still have to implement a bunch of code that I don't know how it works

        self.rewardMedian = numpy.median(rewList)
        self.fillMedian = numpy.median(fillList)
        self.timeMaxMedian = numpy.median(tMaxList)
        self.timeAverageFailMedian = numpy.median(atFailList)
        self.timeAverageSuccMedian = numpy.median(atSuccList)
        self.timeStdDevFailMedian = numpy.median(stdtFailList)
        self.timeStdDevSuccMedian = numpy.median(stdtSuccList)

        return flights


    def mergeLists(self, l1, l2):
        c = []
        for i in l1:
            c.append(i)
        for i in l2:
            c.append(i)
        return c


    def Median(self, values):
        values.sort()
        if (len(values) % 2)== 1:
            return values[(len(values)+1)/2-1]
        else:
            lower = values[len(values)/2-1]
            upper = values[len(values)/2]
            return (lower+upper)/2.0


    def isDouble(self, string):
        return type(string) == type(float())


    def productHighPrecision(self, *dbls):
        base = decimal.Decimal(1.0)
        for d in dbls:
            base *= decimal.Decimal(d)
        return base


    def sumHighPrecision(self, dbls):
        base = decimal.Decimal(1.0)
        for d in dbls:
            base += decimal.Decimal(d)
        return base


    def nextGaussian(self, mean, std_dev):
        return random.gauss(0.0, 1)*(std_dev**2) + mean


    def clearFile(self, fName):
        fileTemp = open(Path(fName), "w+")
        if os.path.isfile(fName):
            os.remove(fileTemp)


    def roundDouble(self, value, sigFigs):
        return round(value * (10**sigFigs))/(10**sigFigs)