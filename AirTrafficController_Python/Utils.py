import ParameterCore
import FlightPlanBootstrapSplitEnum
import FlightPlanCoordinator
from FlightPlan import FlightPlan
import Placement
import random
import decimal
import time
import numpy
import os
import OptimizingThread
import threading
from Flight import Flight


class Utils:                              # public class Utils {
    # Fill-in values for missing data. Generated by reading in the CSV.
    def __init__(self):
        self.rewardMedian = 0.0           # public static Double rewardMedian   ;
        self.fillMedian = 0.0             # public static Double fillMedian     ;
        self.timeMaxMedian = 0.0          # public static Double timeMaxMedian  ;
        self.timeAverageFailMedian = 0.0  # public static Double timeAverageFailMedian
        self.timeAverageSuccMedian = 0.0  # public static Double timeAverageSuccMedian
        self.timeStdDevFailMedian = 0.0   # public static Double timeStdDevFailMedian
        self.timeStdDevSuccMedian = 0.0   # public static Double timeStdDevSuccMedian
        self.rand = random.Random()       # public static Random rand = new Random()  ;


    def preProcessFlights(self, fl):
        toRemove = []
        for f in fl:
            if f.getReward() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                f.setReward(self.rewardMedian * ParameterCore.ParameterCore().NO_REWARD_DEMERIT_COEFF)
                f.setNoDat(True)
            if f.getProbability() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                f.setProbability(self.fillMedian)
                f.setNoDat(True)
            if f.getTimeMax() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                f.setTimeMax(self.timeMaxMedian)
                f.setNoDat(True)
            if f.getTimeAverageFailure() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeAverageSuccess() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeAverageFailure(f.getTimeAverageSuccess)
                else:
                    f.setTimeAverageFailure(self.timeAverageFailMedian)
            if f.getTimeAverageSuccess() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeAverageFailure() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeAverageSuccess(f.getTimeAverageFailure)
                else:
                    f.setTimeAverageSuccess(self.timeAverageSuccMedian)
            if f.getTimeStdDevFailure() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeStdDevSuccess() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeStdDevFailure(f.getTimeStdDevSuccess)
                else:
                    f.setTimeStdDevFailure(self.timeStdDevFailMedian)
            if f.getTimeStdDevSuccess() <= ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                if f.getTimeStdDevFailure() > ParameterCore.ParameterCore().CLOSE_TO_ZERO:
                    f.setTimeStdDevSuccess(f.getTimeStdDevFailure())
                else:
                    f.setTimeStdDevSuccess(self.timeStdDevSuccMedian)
            if f.getNoDat() and ParameterCore.ParameterCore().SKIP_NODAT:
                    toRemove.append(f)
        if ParameterCore.ParameterCore().SKIP_NODAT:
            fl = [x for x in fl if x not in toRemove]

    def partitionToPlacements(self, allFlights):
        pHash = dict()
        for f in allFlights:
            if f.getPlacementToken() in pHash.keys():
                p = pHash[f.getPlacementToken()]
                p.addFlight(f)
            else:
                nfp = FlightPlan([])
                pHash.update({f.getPlacementToken(): Placement.Placement(f.getPlacementToken(), nfp)})
                nfp.addFlight(f)
        return list(pHash.values())





    def optimizePlacements(self, waterfallSizeLimit, control, allPlacements):
        self.clearFile(ParameterCore.ParameterCore().LOG_LOC)
        ########## PrintWriter logger  = new PrintWriter( new FileWriter( ParameterCore.LOG_LOC) );
        semaphore = threading.Semaphore(ParameterCore.ParameterCore().CORES)
        with open(ParameterCore.ParameterCore().LOG_LOC, "w+") as logger:            # logger = PrintWriter(FileWriter(ParameterCore.ParameterCore().LOG_LOC))

            alot = []   # ArrayList<OptimizingThread> alot = new ArrayList<OptimizingThread> ();
            done = 1

            if ParameterCore.ParameterCore().RUN_PARALLEL:
                for p in allPlacements:
                    alot.append(OptimizingThread.OptimizingThread(waterfallSizeLimit, control, semaphore, p))
                    alot[(len(alot) - 1)].run()

                for t in alot:
                    t.join()
                    s = "{} : {} : {} : {} : {} : {}\n".format(int(round(time.time() * 1000)), done, allPlacements.size(), t.getPid(), t.getP().getFp().size(), t.getExp())
                    logger.write(s)
                    logger.flush()
                    done += 1

            else:
                for p in allPlacements:
                    self.optimizePlacement(waterfallSizeLimit, control, p)
                    s = "{} : {} : {} : {} : {} : {}\n".format(int(round(time.time() * 1000)), done, len(allPlacements), p.getPid(), p.getFp().size(),p.getFp().getExpectedValue())
                    logger.write(s)
                    logger.flush()
                    done += 1
        logger.close()



    def optimizePlacement(self, waterfallSizeLimit, control, p):
        fallSize = min(waterfallSizeLimit, p.size())
        candidates = p.getFp().getAsList()
        fp = None
        # Initial flight plan, on which to run optimization. (Order by decreasing reward).
		# Split off the N highest reward flights.
		# Note: candidates IS modified after the operation.

        if ParameterCore.ParameterCore().BOOTSTRAP_METHOD == FlightPlanBootstrapSplitEnum.FlightPlanBootstrapSplitEnum().ORDERED_SPLIT:
            result = FlightPlanCoordinator.ordSplit(fallSize, candidates)
            fp = result[0]
            candidates = result[1]
            fp.makeAdmissible()
        elif ParameterCore.ParameterCore().BOOTSTRAP_METHOD == FlightPlanBootstrapSplitEnum.FlightPlanBootstrapSplitEnum().RANDOM_SPLIT:
            result = FlightPlanCoordinator.randSplit(fallSize, candidates)
            fp = result[0]
            candidates = result[1]
        else:
            raise AssertionError()

        # Optimize START.
        fpc = FlightPlanCoordinator.FlightPlanCoordinator(fp, candidates)
        if "s" == ParameterCore.ParameterCore().DO_BFS:
            fp = fpc.runBruteForce()
        else:
            fp = fpc.runSLS()
        p.setFp(fp)
        # Optimize END.

        # Process all rows of input data that return true.
        def doProcessRow(self, rowIndex):
            if ParameterCore.ParameterCore().SKIP_FIRST_ROW and rowIndex == 0:
                return False
            return True



    # placementToken, flight_id, cpm, fillRateProbability, latency for failure in seconds, latency of success in seconds.
    def readFlightsCSV(self, csv, inFiNa):
        self.flights = []
        self.rewardMedian = None
        self.fillMedian = None
        self.timeAverageFailMedian = None
        self.timeAverageSuccMedian = None
        self.timeMaxMedian = None

        self.rewList = []
        self.fillList = []
        self.tMaxList = []
        self.atFailList = []
        self.atSuccList = []
        self.stdtFailList = []
        self.stdtSuccList = []

        self.rewList.append(0.0)
        self.fillList.append(0.0)
        self.tMaxList.append(0.0)
        self.atFailList.append(0.0)
        self.atSuccList.append(0.0)
        self.stdtFailList.append(0.0)
        self.stdtSuccList.append(0.0)

        i = 0
        with open(inFiNa) as csvfile:
            for x in csvfile.readlines():
                if i != 0:
                    self.procRow(x.split(','))
                i += 1


        self.rewardMedian = numpy.median(self.rewList)
        self.fillMedian = numpy.median(self.fillList)
        self.timeMaxMedian = numpy.median(self.tMaxList)
        self.timeAverageFailMedian = numpy.median(self.atFailList)
        self.timeAverageSuccMedian = numpy.median(self.atSuccList)
        self.timeStdDevFailMedian = numpy.median(self.stdtFailList)
        self.timeStdDevSuccMedian = numpy.median(self.stdtSuccList)

        return self.flights

    def procRow(self, values):
        for x in values:
            if len(x) == 0:
                return
        row         = values
        pTok        = row[0]
        fId         = str(row[1])
        reward      = float(row[2])
        fillRate    = float(row[3])
        t_maxx      = float(row[4])
        t_fail      = float(row[5])
        t_succ      = float(row[6])
        t_fail_std  = float(row[7])
        t_succ_std  = float(row[8].strip("\r\n"))

        self.rewList.append(float(reward)) if reward > 0.0 else None
        self.fillList.append(float(fillRate)) if fillRate > 0.0 else None
        self.tMaxList.append(float(t_maxx)) if t_maxx > 0.0 else None
        self.atFailList.append(float(t_fail)) if t_fail > 0.0 else None
        self.atSuccList.append(float(t_succ)) if t_succ > 0.0 else None
        self.stdtFailList.append(float(t_fail_std)) if t_fail_std > 0.0 else None
        self.stdtSuccList.append(float(t_succ_std)) if t_succ_std > 0.0 else None

        self.flights.append(Flight(pTok, fId, reward, fillRate, t_maxx, t_fail, t_succ, t_fail_std, t_succ_std))


    def mergeLists(self, l1, l2):
        c = []
        for i in l1:
            c.append(i)
        for i in l2:
            c.append(i)
        return c


    def Median(self, values):
        values.sort()
        if (len(values) % 2)== 1:
            return values[(len(values)+1)/2-1]
        else:
            lower = values[len(values)/2-1]
            upper = values[len(values)/2]
            return (lower+upper)/2.0


    def isDouble(self, string):
        return type(string) == type(float())


    def productHighPrecision(self, *dbls):
        base = decimal.Decimal(1.0)
        for d in dbls:
            base *= decimal.Decimal(d)
        return base


    def sumHighPrecision(self, dbls):
        base = decimal.Decimal(1.0)
        for d in dbls:
            base += decimal.Decimal(d)
        return base


    def nextGaussian(self, mean, std_dev):
        return random.gauss(0.0, 1)*(std_dev**2) + mean


    def clearFile(self, fName):
        with open(fName, "w+"):
            pass


    def roundDouble(self, value, sigFigs):
        return round(value * (10**sigFigs))/(10**sigFigs)
